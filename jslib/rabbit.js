// Generated by CoffeeScript 1.6.3
(function() {
  var amqp, async, c, connection, exchange, extend, queue, shared,
    _this = this;

  c = require('node-config');

  amqp = require('amqp');

  extend = require('extend');

  async = require('async');

  shared = require('./shared');

  /*
  Assumptions
    1 rabbit connection
    1+ queue
    1+ exchange
  
  Example
    rabbit
      host:
      port:
      queues: [
        name:
        exchange: 
        opts:
      ]
      exchanges: [
        name:
        opts:
      ]
  */


  connection = {
    newConnection: function(cb) {
      var conn, missing;
      missing = shared.missingParameters(["host", "port"], c.rabbit);
      if (missing) {
        return cb(new Error(missing));
      }
      conn = amqp.createConnection({
        host: c.rabbit.host,
        port: parseInt(c.rabbit.port)
      });
      conn.on("ready", function() {
        var _base;
        if ((_base = _this.app).rabbit == null) {
          _base.rabbit = {};
        }
        _this.app.rabbit.conn = conn;
        return typeof cb === "function" ? cb() : void 0;
      });
      return conn.once("error", function(err) {
        conn.disconnect();
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
      });
    },
    setUp: function(cb) {
      var conn, key, _base;
      conn = ((function() {
        var _i, _len, _ref, _results;
        _ref = ["conn", "connection"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          if (c.rabbit[key] != null) {
            _results.push(c.rabbit[key]);
          }
        }
        return _results;
      })())[0];
      if (conn == null) {
        return connection.newConnection(cb);
      } else {
        if ((_base = _this.app).rabbit == null) {
          _base.rabbit = {};
        }
        _this.app.rabbit.conn = conn;
        return typeof cb === "function" ? cb() : void 0;
      }
    },
    tearDown: function(cb) {
      if (_this.app.rabbit.conn == null) {
        return typeof cb === "function" ? cb() : void 0;
      }
      _this.app.rabbit.conn.disconnect();
      delete _this.app.rabbit.conn;
      return typeof cb === "function" ? cb() : void 0;
    }
  };

  exchange = {
    newExchange: function(obj, cb) {
      var e, missing, opts;
      missing = shared.missingParameters(["name", "key"], obj);
      if (missing) {
        return cb(new Error(missing));
      }
      opts = {
        confirm: true
      };
      if (obj.opts != null) {
        extend(true, opts, obj.opts);
      }
      e = _this.app.rabbit.conn.exchange(obj.name, opts);
      e.on("open", function() {
        _this.app.rabbit[obj.key] = e;
        return cb();
      });
      return e.once("error", function(err) {
        if (err) {
          return cb(err);
        }
      });
    },
    setUp: function(cb) {
      var e;
      e = c.rabbit.exchanges != null ? c.rabbit.exchanges : c.rabbit.exchange != null ? [c.rabbit.exchange] : null;
      if (e == null) {
        return typeof cb === "function" ? cb() : void 0;
      }
      return async.each(e, exchange.newExchange, function(err) {
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        return typeof cb === "function" ? cb() : void 0;
      });
    },
    tearDown: function(cb) {
      var e, obj, _, _i, _len;
      e = c.rabbit.exchanges != null ? c.rabbit.exchanges : c.rabbit.exchange != null ? [c.rabbit.exchange] : null;
      if (e == null) {
        return typeof cb === "function" ? cb() : void 0;
      }
      _ = function(key) {
        return delete _this.app.rabbit[key];
      };
      for (_i = 0, _len = e.length; _i < _len; _i++) {
        obj = e[_i];
        _(obj.key);
      }
      return typeof cb === "function" ? cb() : void 0;
    }
  };

  queue = {
    newQueue: function(obj, cb) {
      var missing, opts;
      missing = shared.missingParameters(["name", "key"], obj);
      if (missing != null) {
        return cb(new Error(missing));
      }
      opts = obj.opts != null ? obj.opts : {};
      return _this.app.rabbit.conn.queue(obj.name, opts, function(q) {
        var rk;
        _this.app.rabbit[obj.key] = q;
        if (obj.exchange == null) {
          return typeof cb === "function" ? cb() : void 0;
        }
        rk = obj.routing != null ? obj.routing : "*";
        return q.bind(obj.exchange, rk, function(q) {
          return typeof cb === "function" ? cb() : void 0;
        });
      });
    },
    setUp: function(cb) {
      var q;
      q = c.rabbit.queues != null ? c.rabbit.queues : c.rabbit.queue != null ? [c.rabbit.queue] : null;
      if (q == null) {
        return typeof cb === "function" ? cb() : void 0;
      }
      return async.each(q, queue.newQueue, function(err) {
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        return typeof cb === "function" ? cb() : void 0;
      });
    },
    tearDown: function(cb) {
      return typeof cb === "function" ? cb() : void 0;
    }
  };

  exports.setUp = function(app, cb) {
    _this.app = app;
    if (c.rabbit == null) {
      return typeof cb === "function" ? cb(null, _this.app) : void 0;
    }
    return async.waterfall([connection.setUp, exchange.setUp, queue.setUp], function(err) {
      if (err != null) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      return typeof cb === "function" ? cb() : void 0;
    });
  };

  exports.tearDown = function(app, cb) {
    _this.app = app;
    return async.waterfall([queue.tearDown, exchange.tearDown, connection.tearDown], function(err) {
      if (err != null) {
        return typeof cb === "function" ? cb(err) : void 0;
      }
      return typeof cb === "function" ? cb() : void 0;
    });
  };

}).call(this);
